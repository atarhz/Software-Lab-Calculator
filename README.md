# گزارش اول آزمایشگاه نرم افزار
## مدیریت نسخ پروژه و یکپارچه سازی مستمر
---
#### در وهله ی اول در این آزمایش مخزن یا همان ریپازیتوری ایجاد کردیم. سپس با دستورات clone پروژه رو دریافت کردیم و با دستور git checkout -b شاخه های متعددی را برای تفکیک برنامه نویسی قسمت های مختلف ایجاد کردیم. تغییرات اعمال شده را با دستور git add . به گیت اضافه کرده و با دستور git commit -m متن پیام برای کامیت ها گذاشتیم تا مدیریت آنها راحت تر شود و بدانیم که چه زمانی چه تغییراتی را اعمال کرده ایم. در نهایت این تغییرات را با دستور git push بر روی شاخه مربوطه گذاشتیم. در انتهای تغییرات هر شاخه، شاخه را با شاخه اصلی merge کردیم تا نسخه نهایی داشته باشیم. در این مرحله قسمت های اولیه آزمایش پوشش داده شد البته شایان ذکر است که به علت خواست آزمایش، در دو مورد تداخل و کانفلیکت های دستی را لحاظ کردیم که در ادامه به شرح آنها می پردازیم.
---
#### در گام نسخت پس از دریافت پروژه از گیت، فایل gitignore را در آن قرار دادیم. این فایل مجدد بعد ها تغییر کرد اما در همان ابتدا به پروژه اضافه شد.آدرس هایی داخل این فایل قرار می گیرند که Untrack باشند و گیت از مدیریت نسخه های آن ها صرف نظر می کند و حتی هنگام دریافت  پروژه منتقل نمی شوند. ما فایل های اضافه ی IDE و React و JS را در این فایل قرار دادیم.
---
#### در قسمت سوم آزمایش حداقل ۲۰ کامیت معنا دار خواسته شده بود که ما طی روند برنامه نویسی این امر را محقق کردیم.
---
#### قسمت چهارم مربوط به شاخه ها یا همان branch ها بود. ما در این پروژه شاخه ای را به جهت انجام اصلاحات و تغییرات فنی در جهت بهبود به نام refactor در نظر گرفتیم. قسمت های اصلی و منطقی پروژه داخل شاخه ی dev کد زده شدند. استایل و موارد مرتبط با طراحی و دیزاین در شاخه style انجام شدند و در نهایت همه این شاخه ها در ضاخه اصلی گرد هم آمدند.
---
#### در بخش پنجم، دو کانفلیکت و تداخل خواسته شده بین شاخه ها حین ادغام دو شاخه بررسی و اصلاح شد. [تداخل اول](https://github.com/atarhz/Software-Lab-Calculator/commit/73b74488a6bae146242b68d9b2a40d1e20382414) و [تداخل دوم](https://github.com/atarhz/Software-Lab-Calculator/commit/42de13c7c4345c66c6e7fb8d5eb5496d88d4afe3).
---
#### در قسمت ششم، با استفاده از منوی تنظیمات، تنظیمات شاخه ها، از شاخه اصلی خود حین ادغام حفاظت کرده و محدودیت هایی را بر ان اعمال کردیم که در عکس ![عکس](https://github.com/atarhz/Software-Lab-Calculator/blob/main/Screenshot%202023-10-29%20at%2015.21.04.png) مشاهده می کنید. در انتها تمام ادغام ها از طریق PL انجام شدند و پروژه کامل بر روی شاخه main قرار گرفت.
---
---
---
### پرسش ها :
#### ** سوال اول،** پوشه .git یک پوشه پنهان است که هنگام ساخت یک repository جدید با دستور git init ایجاد می شود. این فایل حاوی اطلاعاتی نظیر تاریخچه کامیت ها و remote repository address است که می تواند فرایند rollback یا جا به جایی بین ورژن ها را میسر سازد.
#### ** سوال دوم،** کامیت و درخواست ادغام اتمی به این معنی است که آنها کوچک ترین اندازه ممکن را دارند. هر commit فقط و تنها فقط یک کار ساده انجام می دهد که می تواند در یک جمله و متن کامیت ساده خلاصه شود. مقدار تغییر کد مهم نیست. برای درخواست ادغام نیز این قضیه صادق است که هر درخواست ادغام تنها و تنها برای یک کار مشخص و واحد کوچک انجام شود نه آنکه مجموعه ای از کامیت های مختلف ادغام شوند.
#### ** سوال سوم،** دستور fetch تغییرات را دریافت می‌کند اما آنها را به کد اعمال نمی‌کند دستور pull تغییرات را دریافت کرده و همچنین آنها را اعمال می‌کند. دستور merge دو شاخه را با یکدیگر ادغام می‌کند و دستور rebase مشابه merge است با این تفاوت که دستور merge ساده و عامیانه تر است، تاریخچه و ترتیب وقوع را حفظ می کند اما همین امر خطایابی در ان را سخت می کند. دستور rebase یک تاریخچه پیچیده را ساده‌سازی می‌کند.دستکاری یک commit تنها ساده است و از وجود نویز در ropeهای مشغول که شاخه‌های مشغولی دارند، جلوگیری می‌کند. همچنین با تبدیل کردن commitهای حد واسط به یک commit تنها که می‌تواند برای گروه‌های توسعه دهنده کاربردی باشد، آن‌ها را مرتب می‌کند. اما در مقابل Rebase کردن مخازن عمومی می‌تواند در هنگام کار به عنوان یک تیم، خطرناک باشد و کار بیشتری مورد نیاز است: استفاده از rebase برای بروز نگه داشتن شاخه ویژگی خود.
#### ** سوال چهارم،** دستور reset تغییراتی که انجام شده اند را به حالت قبل برمی‌گرداند و تاریخچه commit را تغییر می‌دهد در صورتی که دستور revert به یک commit انتخاب شده برمی گردد ولی تاریخچه commit را حفظ می‌کند. دستور restore به کل فایل‌ها را به حالت قبلی خود برمی‌گرداند.
#### ** سوال پنجم،** Stage یک مرحله در git است که در آن تغییراتی که قرار است commit شوند، آماده می‌شوند. Git دارای سه حالت اصلی است که فایل‌های شما می‌توانند در آن‌ها قرار گیرند: ‌modified، staged و committed. اصلاح شده یا همان modified به این معنی است که شما فایل را تغییر داده‌اید اما هنوز آن را به پایگاه داده خود کامیت نکرده‌اید. مرحله بندی شده یا همان staged به این معنی است که شما یک فایل اصلاح شده را در نسخه فعلی آن علامت گذاری کرده اید تا به commit snapshot بعدی بروید. دستور stash تغییرات را در یک محل موقت ذخیره می‌کند تا بتوانید بدون اعمال آنها به کار خود ادامه دهید. به عبارتی دستور git stash تغییرات کامیت نشده شما (هم مرحله‌ای و هم بدون مرحله) را می‌گیرد، آن‌ها را برای استفاده بعدی ذخیره می‌کند و سپس آنها را از کپی کاری شما برمی‌گرداند.
#### ** سوال ششم،** Snapshot در git شامل وضعیت تمام فایل های ردیابی شده در یک مخزن است به معنی اینکه یک تصویر از وضعیت فعلی فایل‌ها در یک زمان خاص است. هر زمان که یک commit ایجاد می‌کنید، git یک snapshot از وضعیت فعلی فایل‌ها می‌گیرد و آن را ذخیره می‌کند.

